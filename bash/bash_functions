#
# path_add <path> [direction] [varname]
#
# path_add takes a directory name, an optional direction name (defaults to
# "after" to append to list) and an optional variable name (defaults to PATH)
# and adds the directory name to data stored in variable.
#
# Example
#
# given: PATH='/bin:/sbin'
#
# path_add /usr/bin
# // PATH => '/bin:/sbin:/usr/bin'
# path_add /opt/local/bin before
# // PATH => '/opt/local/bin:/bin:/sbin:/usr/bin'
#
# The variable name should be passed by name.
# foo=''
# path_add /bin after foo
# // foo => '/bin'
#
path_add() {
	local var=${3:-PATH}
	local path=
	path=$(path_print_add "$@") || return 1
	read -r "${var?}" <<< "$path"
}

#
# path_remove <path> [varname]
#
# path_remove takes a directory name and an optional variable name (defaults to
# PATH) and removes every instance of the directory name from the data stored in
# the variable.
#
# Example
#
# given: PATH='/bin:/sbin:/usr/bin:/usr/sbin'
#
# path_remove /usr/bin
# // PATH => '/bin:/sbin:/usr/sbin'
# path_remove /not-found
# // PATH => '/bin:/sbin:/usr/sbin'
#
# The variable name should be passed by name.
# foo='/bin:/sbin'
# path_remove /bin foo
# // foo => '/sbin'
#
path_remove() {
	local var=${2:-PATH}
	local path=
	path=$(path_print_remove "$@") || return 1
	read -r "${var?}" <<< "$path"
}

#
# path_clean [varname]
#
# path_clean takes an optional variable name (defaults to PATH) and "cleans" it,
# this process will:
#
# 1. Remove empty elements.
# 2. Remove relative directories.
# 3. Remove directories that don't exist/can't be accessed (checked with `cd`).
# 4. Remove duplicates (first element stays, subsequent elements are tossed).
#
# Example
#
# PATH='::/bin:/sbin:::./:../../some-path::/doesnt-exist'
# path_clean
# // PATH => '/bin:/sbin'

# PATH='/bin:/bin//:////bin//////:/bin/dir/..::'
# path_clean
# // PATH => '/bin'
#
# The variable name should be passed by name.
# foo='/bin:/bin'
# path_clean /bin foo
# // foo => '/bin'
#
path_clean() {
	local var=${1:-PATH}
	local path=
	path=$(path_print_clean "$@") || return 1
	read -r "${var?}" <<< "$path"
}

#
# Exact same usage as path_add but prints the new PATH only and doesn't modify
# anything in place.
#
path_print_add() {
	local p=$1
	local dir=${2:-after}
	local var=${3:-PATH}
	local arr
	declare -A seen

	if [[ -z $p || $p == *:* ]]; then
		echo "path_print_add: invalid argument: '$p'" >&2
		return 1
	fi

	IFS=: read -ra arr <<< "${!var}:"

	case "$dir" in
		after) arr=("${arr[@]}" "$p");;
		*) arr=("$p" "${arr[@]}");;
	esac

	local IFS=:
	echo "${arr[*]}"
}

#
# Exact same usage as path_remove but prints the new PATH only and doesn't
# modify anything in place.
#
path_print_remove() {
	local p=$1
	local var=${2:-PATH}
	local arr
	local newarr=()
	declare -A seen

	if [[ -z $p || $p == *:* ]]; then
		echo "path_print_remove: invalid argument: '$p'" >&2
		return 1
	fi

	IFS=: read -ra arr <<< "${!var}:"

	local _p
	for _p in "${arr[@]}"; do
		if [[ $p == "$_p" ]]; then
			continue
		fi
		newarr+=("$_p")
	done

	local IFS=:
	echo "${newarr[*]}"
}

#
# Exact same usage as path_clean but prints the new PATH only and doesn't
# modify anything in place.
#
path_print_clean() {
	local var=${1:-PATH}
	local arr
	local newarr=()
	declare -A seen

	# read PATH into an array, trailing ":" is due to:
	# http://mywiki.wooledge.org/BashPitfalls#pf47
	IFS=: read -ra arr <<< "${!var}:"

	local p
	for p in "${arr[@]}"; do
		# Empty element is equivalent to CWD (weird, I know), remove it
		if [[ -z $p ]]; then
			continue
		fi

		# Remove any relative paths
		if [[ ${p:0:1} != '/' ]]; then
			continue
		fi

		# Normalize path and ensure we can access it
		p=$(cd "$p" &>/dev/null && echo "$PWD")

		# Path doesn't exist or we can't access it
		if [[ -z $p ]]; then
			continue
		fi

		# Filter out dups while we are here
		if [[ -n ${seen[$p]} ]]; then
			continue
		fi
		seen[$p]=true

		# Store the new path
		newarr+=("$p")
	done

	local IFS=:
	echo "${newarr[*]}"
}


# because `master` is sometimes `main` (or others), these must be functions.
gmb() { # git main branch
	local main
	main=$(git symbolic-ref --short refs/remotes/origin/HEAD)
	main=${main#origin/}
	[[ -n $main ]] || return 1
	echo "$main"
}

# show the diff from inside a branch to the main branch
gbd() { # git branch diff
	local mb=$(gmb) || return 1
	git diff "$mb..HEAD"
}

# checkout the main branch and update it
gcm() { # git checkout $main
	local mb=$(gmb) || return 1
	git checkout "$mb" && git pull
}

# merge the main branch into our branch
gmm() { # git merge $main
	local mb=$(gmb) || return 1
	git merge "$mb"
}

# print a colorized diff
colordiff() {
	local red=$(tput setaf 1 2>/dev/null)
	local green=$(tput setaf 2 2>/dev/null)
	local cyan=$(tput setaf 6 2>/dev/null)
	local reset=$(tput sgr0 2>/dev/null)

	diff -u "$@" | awk "
	/^\-/ {
		printf(\"%s\", \"$red\");
	}
	/^\+/ {
		printf(\"%s\", \"$green\");
	}
	/^@/ {
		printf(\"%s\", \"$cyan\");
	}

	{
		print \$0 \"$reset\";
	}"

	return "${PIPESTATUS[0]}"
}

# Print all 256 colors
colors() {
	local i
	for i in {0..255}; do
		printf "\x1b[38;5;${i}mcolor %d\n" "$i"
	done
	tput sgr0
}

# Copy stdin to the clipboard
copy() {
	pbcopy 2>/dev/null ||
		xsel 2>/dev/null ||
		clip.exe

}

# Convert epoch to human readable (print current date if no args)
epoch() {
	local num=${1:--1}
	printf '%(%B %d, %Y %-I:%M:%S %p %Z)T\n' "$num"
}

# Open the current path or file in GitHub
gho() {
	local file=$1
	local remote=${2:-origin}

	# get the git root dir, branch, and remote URL
	local gr=$(git rev-parse --show-toplevel)
	local branch=$(git rev-parse --abbrev-ref HEAD)
	local url=$(git config --get "remote.$remote.url")

	[[ -n $gr && -n $branch && -n $remote ]] || return 1

	# construct the path
	local path=${PWD/#$gr/}
	[[ -n $file ]] && path+=/$file

	# extract the username and repo name
	local a
	IFS=:/ read -a a <<<"$url"
	local len=${#a[@]}
	local user=${a[len - 2]}
	local repo=${a[len - 1]%.git}

	url="https://github.com/$user/$repo/tree/$branch$path"
	echo "$url"
	open "$url"
}

# Platform-independent interfaces
interfaces() {
	node <<-EOF
		var os = require('os');
		var i = os.networkInterfaces();
		Object.keys(i).forEach(function(name) {
			i[name].forEach(function(int) {
				if (int.family === 'IPv4') {
					console.log('%s: %s', name, int.address);
				}
			});
		});
	EOF
}

# Calculate CPU load / Core Count
load() {
	node -p <<-EOF
		var os = require('os');
		var c = os.cpus().length;
		os.loadavg().map(function(l) {
			return (l/c).toFixed(2);
		}).join(' ');
	EOF
}

# Platform-independent memory usage
meminfo() {
	node <<-EOF
		var os = require('os');
		var free = os.freemem();
		var total = os.totalmem();
		var used = total - free;
		console.log('memory: %dmb / %dmb (%d%%)',
		    Math.round(used / 1024 / 1024),
		    Math.round(total / 1024 / 1024),
		    Math.round(used * 100 / total));
	EOF
}

# print lines over X columns (defaults to 80)
over() {
	awk -v c="${1:-80}" 'length($0) > c {
		printf("%4d %s\n", NR, $0);
	}'
}

# print a rainbow if truecolor is available to the terminal
truecolor-rainbow() {
	local i r g b
	for ((i = 0; i < 77; i++)); do
		r=$((255 - (i * 255 / 76)))
		g=$((i * 510 / 76))
		b=$((i * 255 / 76))
		((g > 255)) && g=$((510 - g))
		printf '\033[48;2;%d;%d;%dm ' "$r" "$g" "$b"
	done
	tput sgr0
	echo
}

# Follow redirects to untiny a tiny url
untiny() {
	local location=$1
	local last_location=''

	while [[ -n $location ]]; do
		[[ -n $last_location ]] && echo " -> $last_location"
		last_location=$location
		read -r _ location < \
			<(curl -sI "$location" | grep 'Location: ' | tr -d '[:cntrl:]')
	done
	echo "$last_location"
}

# Change the prompt colors to a theme, themes are 0-29
set_prompt_colors() {
	local h=${1:-0}
	local color=
	local i=0
	local j=0
	for i in {22..231}; do
		((i % 30 == h)) || continue

		color=${COLOR256[$i]}
		# cache the tput colors
		if [[ -z $color ]]; then
			COLOR256[$i]=$(tput setaf "$i")
			color=${COLOR256[$i]}
		fi
		PROMPT_COLORS[$j]=$color
		((j++))
	done
}

_prompt_command() {
	local user=$USER
	local host=${HOSTNAME%%.*}
	local pwd=${PWD/#$HOME/\~}
	local ssh=
	[[ -n $SSH_CLIENT ]] && ssh='[ssh] '
	printf "\033]0;%s%s@%s:%s\007" "$ssh" "$user" "$host" "$pwd"
}