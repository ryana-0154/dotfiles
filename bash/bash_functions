#!/usr/bin/env bash

path_add() {
	local var=${3:-PATH}
	local path=
	path=$(path_print_add "$@") || return 1
	read -r "${var?}" <<< "$path"
}

path_remove() {
	local var=${2:-PATH}
	local path=
	path=$(path_print_remove "$@") || return 1
	read -r "${var?}" <<< "$path"
}

path_clean() {
	local var=${1:-PATH}
	local path=
	path=$(path_print_clean "$@") || return 1
	read -r "${var?}" <<< "$path"
}

path_print_add() {
	local p=$1
	local dir=${2:-after}
	local var=${3:-PATH}
	local arr
	declare -A seen

	if [[ -z $p || $p == *:* ]]; then
		echo "path_print_add: invalid argument: '$p'" >&2
		return 1
	fi

	IFS=: read -ra arr <<< "${!var}:"

	case "$dir" in
		after) arr=("${arr[@]}" "$p");;
		*) arr=("$p" "${arr[@]}");;
	esac

	local IFS=:
	echo "${arr[*]}"
}

path_print_remove() {
	local p=$1
	local var=${2:-PATH}
	local arr
	local newarr=()
	declare -A seen

	if [[ -z $p || $p == *:* ]]; then
		echo "path_print_remove: invalid argument: '$p'" >&2
		return 1
	fi

	IFS=: read -ra arr <<< "${!var}:"

	local _p
	for _p in "${arr[@]}"; do
		if [[ $p == "$_p" ]]; then
			continue
		fi
		newarr+=("$_p")
	done

	local IFS=:
	echo "${newarr[*]}"
}

path_print_clean() {
	local var=${1:-PATH}
	local arr
	local newarr=()
	declare -A seen

	# read PATH into an array, trailing ":" is due to:
	# http://mywiki.wooledge.org/BashPitfalls#pf47
	IFS=: read -ra arr <<< "${!var}:"

	local p
	for p in "${arr[@]}"; do
		# Empty element is equivalent to CWD (weird, I know), remove it
		if [[ -z $p ]]; then
			continue
		fi

		# Remove any relative paths
		if [[ ${p:0:1} != '/' ]]; then
			continue
		fi

		# Normalize path and ensure we can access it
		p=$(cd "$p" &>/dev/null && echo "$PWD")

		# Path doesn't exist or we can't access it
		if [[ -z $p ]]; then
			continue
		fi

		# Filter out dups while we are here
		if [[ -n ${seen[$p]} ]]; then
			continue
		fi
		seen[$p]=true

		# Store the new path
		newarr+=("$p")
	done

	local IFS=:
	echo "${newarr[*]}"
}


# because `master` is sometimes `main` (or others), these must be functions.
gmb() { # git main branch
	local main
	main=$(git symbolic-ref --short refs/remotes/origin/HEAD)
	main=${main#origin/}
	[[ -n $main ]] || return 1
	echo "$main"
}

# show the diff from inside a branch to the main branch
gbd() { # git branch diff
	local mb
	mb=$(gmb) || return 1
	git diff "$mb..HEAD"
}

# checkout the main branch and update it
gcm() { # git checkout $main
	local mb
	mb=$(gmb) || return 1
	git checkout "$mb" && git pull
}

# merge the main branch into our branch
gmm() { # git merge $main
	local mb
	mb=$(gmb) || return 1
	git merge "$mb"
}

# print a colorized diff
colordiff() {
	local red
	red=$(tput setaf 1 2>/dev/null)
	local green
	green=$(tput setaf 2 2>/dev/null)
	local cyan
	cyan=$(tput setaf 6 2>/dev/null)
	local reset
	reset=$(tput sgr0 2>/dev/null)

	diff -u "$@" | awk "
	/^\-/ {
		printf(\"%s\", \"$red\");
	}
	/^\+/ {
		printf(\"%s\", \"$green\");
	}
	/^@/ {
		printf(\"%s\", \"$cyan\");
	}

	{
		print \$0 \"$reset\";
	}"

	return "${PIPESTATUS[0]}"
}

# Print all 256 colors
colors() {
	local i
	for i in {0..255}; do
		printf "\x1b[38;5;${i}mcolor %d\n" "$i"
	done
	tput sgr0
}

# Copy stdin to the clipboard
copy() {
	pbcopy 2>/dev/null ||
		xsel 2>/dev/null ||
		clip.exe

}

# Convert epoch to human readable (print current date if no args)
epoch() {
	local num=${1:--1}
	printf '%(%B %d, %Y %-I:%M:%S %p %Z)T\n' "$num"
}

# Open the current path or file in GitHub
gho() {
	local file=$1
	local remote=${2:-origin}

	# get the git root dir, branch, and remote URL
	local gr
	gr=$(git rev-parse --show-toplevel)
	local branch
	branch=$(git rev-parse --abbrev-ref HEAD)
	local url
	url=$(git config --get "remote.$remote.url")

	[[ -n $gr && -n $branch && -n $remote ]] || return 1

	# construct the path
	local path=${PWD/#$gr/}
	[[ -n $file ]] && path+=/$file

	# extract the username and repo name
	local a
	IFS=:/ read -a a <<<"$url"
	local len=${#a[@]}
	local user=${a[len - 2]}
	local repo=${a[len - 1]%.git}

	url="https://github.com/$user/$repo/tree/$branch$path"
	echo "$url"
	open "$url"
}

# Platform-independent interfaces
interfaces() {
	node <<-EOF
		var os = require('os');
		var i = os.networkInterfaces();
		Object.keys(i).forEach(function(name) {
			i[name].forEach(function(int) {
				if (int.family === 'IPv4') {
					console.log('%s: %s', name, int.address);
				}
			});
		});
	EOF
}

# Calculate CPU load / Core Count
load() {
	node -p <<-EOF
		var os = require('os');
		var c = os.cpus().length;
		os.loadavg().map(function(l) {
			return (l/c).toFixed(2);
		}).join(' ');
	EOF
}

# Platform-independent memory usage
meminfo() {
	node <<-EOF
		var os = require('os');
		var free = os.freemem();
		var total = os.totalmem();
		var used = total - free;
		console.log('memory: %dmb / %dmb (%d%%)',
		    Math.round(used / 1024 / 1024),
		    Math.round(total / 1024 / 1024),
		    Math.round(used * 100 / total));
	EOF
}

# print lines over X columns (defaults to 80)
over() {
	awk -v c="${1:-80}" 'length($0) > c {
		printf("%4d %s\n", NR, $0);
	}'
}

# print a rainbow if truecolor is available to the terminal
truecolor-rainbow() {
	local i r g b
	for ((i = 0; i < 77; i++)); do
		r=$((255 - (i * 255 / 76)))
		g=$((i * 510 / 76))
		b=$((i * 255 / 76))
		((g > 255)) && g=$((510 - g))
		printf '\033[48;2;%d;%d;%dm ' "$r" "$g" "$b"
	done
	tput sgr0
	echo
}

# Follow redirects to untiny a tiny url
untiny() {
	local location=$1
	local last_location=''

	while [[ -n $location ]]; do
		[[ -n $last_location ]] && echo " -> $last_location"
		last_location=$location
		read -r _ location < \
			<(curl -sI "$location" | grep 'Location: ' | tr -d '[:cntrl:]')
	done
	echo "$last_location"
}

# Change the prompt colors to a theme, themes are 0-29
set_prompt_colors() {
	local h=${1:-0}
	local color=
	local i=0
	local j=0
	for i in {22..231}; do
		((i % 30 == h)) || continue

		color=${COLOR256[$i]}
		# cache the tput colors
		if [[ -z $color ]]; then
			COLOR256[$i]=$(tput setaf "$i")
			color=${COLOR256[$i]}
		fi
		# shellcheck disable=SC2034
		PROMPT_COLORS[$j]=$color
		((j++))
	done
}

_prompt_command() {
	local user=$USER
	local host=${HOSTNAME%%.*}
	local pwd=${PWD/#$HOME/\~}
	local ssh=
	[[ -n $SSH_CLIENT ]] && ssh='[ssh] '
	printf "\033]0;%s%s@%s:%s\007" "$ssh" "$user" "$host" "$pwd"
}

# Create a new directory and enter it
mkd() {
	mkdir -p "$@" && cd "$_" || exit;
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz() {
	local tmpFile
	# shellcheck disable=SC2124
	tmpFile="${@%/}.tar";
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
	);

	local cmd="";
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli";
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz";
		else
			cmd="gzip";
		fi;
	fi;

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…";
	"${cmd}" -v "${tmpFile}" || return 1;
	[ -f "${tmpFile}" ] && rm "${tmpFile}";

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
	);

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

# Determine size of a file or total size of a directory
fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh;
	else
		local arg=-sh;
	fi
	# shellcheck disable=SC2199
	if [[ -n "$@" ]]; then
		du $arg -- "$@";
	else
		du $arg .[^.]* ./*;
	fi;
}

server() {
	local port="${1:-8000}";
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified.";
		return 1;
	fi;

	local domain="${1}";
	echo "Testing ${domain}…";
	echo ""; # newline

	local tmp
	tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		| openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		local certText
		certText=$(echo "${tmp}" \
			| openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
			no_serial, no_sigdump, no_signame, no_validity, no_version");
		echo "Common Name:";
		echo ""; # newline
		echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
		echo ""; # newline
		echo "Subject Alternative Name(s):";
		echo ""; # newline
		echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
			| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
		return 0;
	else
		echo "ERROR: Certificate not found.";
		return 1;
	fi;
}

tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` (see below) cross-platform.
if [ ! "$(uname -s)" = 'Darwin' ]; then
	if grep -q Microsoft /proc/version; then
		# Ubuntu on Windows using the Linux subsystem
		alias open='explorer.exe';
	else
		alias open='xdg-open';
	fi
fi

# `o` with no arguments opens the current directory, otherwise opens the given
# location
o() {
	if [ $# -eq 0 ]; then
		open .;
	else
		open "$@";
	fi;
}

repo() {
	local base=~/repos
	if [ $# -eq 0 ]; then
		cd "$base" || return
	else
		cd "$base/$1" || return
	fi
}

